import gmpy2
from Crypto.Util.number import *








n = [19833203629283018227011925157509157967003736370320129764863076831617271290326613531892600790037451229326924414757856123643351635022817441101879725227161178559229328259469472961665857650693413215087493448372860837806619850188734619829580286541292997729705909899738951228555834773273676515143550091710004139734080727392121405772911510746025807070635102249154615454505080376920778703360178295901552323611120184737429513669167641846902598281621408629883487079110172218735807477275590367110861255756289520114719860000347219161944020067099398239199863252349401303744451903546571864062825485984573414652422054433066179558897]
e = 3
c = [15239683995712538665992887055453717247160229941400011601942125542239446512492703769284448009141905335544729440961349343533346436084176947090230267995060908954209742736573986319254695570265339469489948102562072983996668361864286444602534666284339466797477805372109723178841788198177337648499899079471221924276590042183382182326518312979109378616306364363630519677884849945606288881683625944365927809405420540525867173639222696027472336981838588256771671910217553150588878434061862840893045763456457939944572192848992333115479951110622066173007227047527992906364658618631373790704267650950755276227747600169403361509144]




from functools import reduce
def chinese_remainder(n, a):#
    sum = 0
    prod = reduce(lambda a, b: a * b, n)
    for n_i, a_i in zip(n, a):
        p = prod // n_i
        sum += a_i * gmpy2.invert(p, n_i) * p
    return int(sum % prod)
for i in range(len(n)):
    for j in range(len(n)):
        for k in range(len(n)):
            if (i!=j)&(i!=k)&(j!=k):
                M=chinese_remainder([n[i],n[j],n[k]],[c[i],c[j],c[k]])
                m = gmpy2.iroot(M,3)[0]
                print(long_to_bytes(m))

# This script implements an RSA decryption attack using the Chinese Remainder Theorem (CRT) for ciphertexts encrypted with the same exponent e = 3 across different moduli n. By combining the ciphertexts and moduli with CRT, it reconstructs a value M that, when cube-rooted, reveals the plaintext message m. The challenge highlights the vulnerability of using small exponents like e = 3 in RSA when messages are not properly padded and the same plaintext is encrypted under multiple moduli.